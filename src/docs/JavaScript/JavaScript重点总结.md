## **原型与原型链**

### 原型

            + 分为显式原型和隐式原型
            + 显示原型:指的是函数上的prototype属性
            + 隐式原型:指的是__proto__属性
            + 都会随着对象的创建而创建,它们都指向一个原型对象

### 原型对象

            + 通过 Object 构造函数生成的,而且我们定义的函数默认都是Object的实例
            + 作用 : 就是可以将它身上的属性和方法共享给由它创建的实例对象
            + 在实例对象的隐式原型是等于其构造函数的显式原型.

### 原型链

            + 前言:在javascript以前,是没有类的概念,也没有继承,而原型链是后来加上的,为的就是将类的思想带入javascript里面
            + 原型链:就是通过对象身上的__proto__属性进行连接所有对象的链
            + 作用:就是制定了对象查找属性的规则
            + 在一个对象身上访问属性,会先在对象自身身上找,如果没有,就继续往它的原型对象身上找,有就返回,没有就返回undefined.

### 应用

    	vue2框架中app实例挂载工具函数.

## **闭包**

### MDN 官网上是这样形容的:

闭包指的是一个函数以及其捆绑的词法环境的引用的组合的,它也是一个对象,里面包含了被函数引用的变量.

说白了就是函数嵌套

### 产生条件:

函数嵌套

内部函数引用外部函数的变量

### 闭包的作用:

在于其可以让我们开发者可以从一个内部函数访问到外部函数的变量.还有就是起到了一个延长变量的生命周期,我们都知道一个正常的函数局部变量,在函数上下文执行完后,就会立即销毁,但闭包就可以帮我们将这个变量保存下来,给予我们一个私有变量,并且不会污染全局命名空间.

总结:

延长变量生命周期。

形成私有变量,不会污染全局命名空间。

### 有效闭包与无效闭包:

有效闭包: 变量生命周期得以延长。

无效闭包: 闭包只存在一瞬间。

### 缺点:

那就是当我们闭包逐渐变多,而有一些对后续代码无用的闭包没有被释放,那就会造成内存泄漏的风险.

### 如何避免闭包副作用:

将无用的闭包引用断开;

减少使用闭包。

## **JS 垃圾回收机制**

        * 在JS中常用的垃圾回收算法有,_**引用计算法,标记清除法**_

### **引用计数算法**

_引用计数法_

原理

就是对每个被引用到的对象,进行计数,根据对象被引用的数量来计算,这个对象是否是一个垃圾对象,只要这个对象被引用到,那他就不会被清除

缺点:

对象的互相引用,因为一旦对象互相引用,那即便外部引用被断开,这个对象也不会被当成垃圾对象,因为它们在对方身上都被引用到了.

### **标记清除算法:**

#### 原理:

                        + 标记清除法,就是标记所有能被找到的对象,而没有被标记的就会被清除,
                        + 它会从跟对象身上递归查找,对没有找到的对象进行标为"活着".之后就会对所有没有被标记的对象进行清除,但是每个对象在内存存储的位置是无序的,对象的大小也不一致.

缺点:

会导致在清除后,所空余出来的内存空间,位置不一,大小不一,也就是**内存碎片化**,还有**内存分配速度慢**

解决方法:

标记整理算法:

在标记结束后,算法会将活着的对象整理至内存的一端,然后将被分配至另一端的垃圾清除,这时就整理出了一个合理的内存空间.

### **v8 引擎垃圾回收优化: **

#### 新生代与老生代

#### 并行回收

## js 事件循环

**js 事件循环机制是为了实现 js 异步代码的内部原理**

            + **执行流程:**
                - _整体流程_
                    * js代码的执行会先从script标签内代码开始执行,当script标签里的同步代码执行完后,在执行微队列中的代码,在微队列执行完,在取出宏队列中的代码进行执行
                - _宏任务:_
                    * 在js中有着定时器,延时器,ajax请求,DOM事件绑定,它们都是宏任务.
                    * 在浏览器中,它们都会有相应的模块管理,当我们的同步代码执行的时候,也会启动一些异步任务.
                    * 当这些异步任务启动的时候,因为js是单线程的所有为了不阻塞主线程的执行,js会将其分给其他辅助线程管理.
                    * 如定时器会将其分给**定时器管理模块,**
                    * 网络请求会分给**网络请求模块,**
                    * dom事件绑定监听,会将其分给**DOM事件管理模块.**
                    * 这些模块会将我们的回调进行存储,当条件达成时,就会将相应的回调,放入宏队列中进行待执行.这些都是宏任务
                - 微任务:
                    * 在js中原先是没有微任务的,直到es6后promise的出现,才有了微任务的概念
                    * 而promise是js代码实现的,因此它是由js自身管理,但是不会阻塞线程的执行,因为它是异步的
                    * 是由微队列进行管理,而微队列先于宏队列执行的
                - 循环原理:
                    * 因为js在执行所有的同步代码后,会先对微队列进行一次判断,如果有则执行微队列中的任务,如果没有则取出宏队列的第一个任务,进行执行.执行完同步后再一次对微队列进行判断,有则执行,无则执行宏任务,依次循环反复.这就是js事件循环的内部原理

## Promise

_**promise 是 es6 推出的一个对回调地狱的解决方案,是异步代码的更好解决方法;**_

            + 使用:
                - 对promise的使用我们一般是通过new调用得到一个promise实例对象
            + 状态:
                - promise对象身上有三种状态,分为
                    * pending状态(准备阶段),
                    * fulfilled(resolved)状态(成功状态),
                    * rejected状态(失败状态)
            + new调用:
                - new Promise的时候我们可以传入一个回调函数
                - 函数的形参:
                    * ,这个函数会被传入两个函数形参,分别是
                        + resolve,
                        + reject,
                    * 调用会发生什么:
                        + 它们的调用决定了promise返回的实例对象的状态:
                        + pending状态:
                            - 当我们未调用这两个函数的时候,Promise对象的状态就会一直处于pending状态;
                        + resolve状态:
                            - ,而当我们调用resolve的时候,Promise对象的状态就会变为成功状态;
                        + reject状态:
                            - 而如果我们调用的是reject,那么这个promise就会是失败状态;
                - 对实例状态的处理:
                    * promise实例对象有相应的方法处理这些状态;
                        + 分别是
                            - then,
                            - catch
                            - finlliy,
                    * then方法:
                        + then方法接收两个回调参数
                            - 第一个:
                                * 第一个回调参数,处理成功状态的promise
                            - 第二个:
                                * 第二个回调处理失败状态的promise
                    * catch方法:
                        + catch本质是then方法处理失败回调的语法糖,
                        + 当我们没有给then方法传入失败的回调,那么promise会默认传入一个失败回调,并将失败的错误返回,而catch就可以接收到promise失败回调传递的错误;
                    * finlliy方法:
                        + 是无论这个promise成功还是失败,都会调用.
            + 静态方法:
                - Promise也有着几个静态方法
                - 分别是:
                    * Promise.resolve():
                        + 返回一个成功的promise.
                    * Promise.reject():
                        + 返回一个失败的promise.
                    * Promise.all():
                        + 接收一个存放promise的数据,会在数组所有promise都为成功的状态的时候,变为成功,返回值是数组中所有promise的成功值,而有一个是失败就变为失败的promise.
                    * Promise.allsettled():
                        + 接收一个promise数组,它不管里面的promise是成功还是失败,只要数组所有promise状态都改变就成功,返回所有promise的结果值数组.
                    * promise.race():
                        + 接收一个promise数组.只要数组中有一个promise状态改变,就成功/失败,返回第一个改变状态promise的值.

## JavaScript 实现存储的方式:

        * cookie:
            + 是最早提出的一种存储方式,在cookie之前服务端是无法判断网络中的两个请求是否是同一个用户发出,所以cookie也就诞生了.
            + cookie的大小只有4KB.
            + 是一个文本
            + 特性:
            + cookie是无法跨域的.
            + 且cookie一旦创建就无法修改
            + 每个域下cookie的个数不能超过二十个.
            +
        * localStorage:
            + 作用
                - 一个实现本地持久化存储,解决存储信息过大的问题,的解决方案
                - localStorage是H5的一个新特性.
                - localStorage是存储在硬盘上的,并不会随着页面和浏览器的关闭而消失,除非主动清除,这也是它能实现持久化存储的原因.
                - 存储大小一般为5MB.
            + 缺点:
                - 存在浏览器兼容问题,IE8一下版本的浏览器并不支持.
                - 浏览器设置为隐私模式,我们将无法读取到localStorage.
                - localStorage受同源策略影响,端口,协议,主机任意一个不同,都无法访问到
        * sessionStorage:
            + 作用:
                - 一个实现临时存储的解决方案.
                - 主要用于临时保存同一窗口/或者说是同一标签页的数据,刷新不会删除
                - 只有关闭窗口或标签页之后才会删除.
            + 特点:
                - sessionStorage是存储在内存中的,也就是关闭即毁.
                - sessionStorage只能在一个标签页下进行访问.
        * indexedDB:
            + 作用
                - 他是一个NoSQL(非关系型)数据库,使用键值对的方式进行存储,可以快速读取.可以使用javascript进行操作.
            + 特点:
                - 采取键值对存储:
                    * 每个主键不得重复
                - 异步操作
                - 支持事务
                    * 在一系列操作中,有一步操作失败,整个事务都会被取消,数据库会回滚至操作之前的状态
                - 遭受同源限制
                - 存储理论无上限
                - 支持二进制存储
        * webSQL:
            + 在2010年被W3C废弃,他是一个类似SQLite的关系型数据库.
